name: Update Ranked Decks JSON

on:
  schedule:
    # Run every 24 hours at midnight UTC
    - cron: "0 0 * * *"
  workflow_dispatch: # Allow manual triggering

jobs:
  update-json:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Fetch commander stats + top 3 recent entries with pagination
      - name: Fetch data from API
        id: fetch_data
        run: |
          total_data="[]"
          after_cursor="null"
          total_count=0
          limit=1800

          while [ $total_count -lt $limit ]; do
            response=$(curl -s -X POST -H "Content-Type: application/json" \
              -d '{"query": "query ($after: String) { commanders(first: 100, sortBy: POPULARITY, minEntries: 0, timePeriod: THREE_MONTHS, after: $after) { edges { cursor node { name stats(filters: { timePeriod: THREE_MONTHS, minSize: 16 }) { conversionRate metaShare } entries(first: 3, filters: { timePeriod: THREE_MONTHS }) { edges { node { player { name } decklist standing tournament { name size } } } } } } pageInfo { endCursor hasNextPage } } }", "variables": {"after": '"$after_cursor"'}}' \
              https://edhtop16.com/api/graphql)

            # If the API returns GraphQL errors, stop early with useful logs
            hasErrors=$(echo "$response" | jq -r '(.errors // empty) | length')
            if [ "$hasErrors" != "" ] && [ "$hasErrors" != "0" ]; then
              echo "GraphQL returned errors:"
              echo "$response" | jq '.errors'
              exit 1
            fi

            edges=$(echo "$response" | jq '.data.commanders.edges')
            edge_count=$(echo "$edges" | jq 'length')
            total_count=$((total_count + edge_count))

            # Trim if exceeding limit
            if [ $total_count -ge $limit ]; then
              remaining_count=$((limit - (total_count - edge_count)))
              edges=$(echo "$edges" | jq ".[0:$remaining_count]")
              total_count=$limit
            fi

            total_data=$(echo "$total_data $edges" | jq -s 'add')

            if [ $total_count -ge $limit ]; then
              break
            fi

            after_cursor=$(echo "$response" | jq '.data.commanders.pageInfo.endCursor')
            hasNextPage=$(echo "$response" | jq -r '.data.commanders.pageInfo.hasNextPage')

            if [ "$hasNextPage" != "true" ]; then
              break
            fi
          done

          # Build ranked stats list
          echo "$total_data" | jq '
            map({
              name: .node.name,
              conversionRate: (.node.stats.conversionRate // 0),
              metaShare: (.node.stats.metaShare // 0)
            })
          ' > parsed-data.json

          # Build recentTopDecks map keyed by commander name
          echo "$total_data" | jq '
            map({
              key: .node.name,
              val: (
                (.node.entries.edges // [])
                | map(.node)
                | map({
                    player: (.player.name // ""),
                    decklist: (.decklist // ""),
                    standing: (.standing // null),
                    tournamentName: (.tournament.name // ""),
                    tournamentSize: (.tournament.size // null)
                  })
              )
            })
            | from_entries
          ' > recent-top-decks.json

      # Step 3: Update the JSON file
      - name: Update JSON file
        run: |
          echo "{\"lastUpdated\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"data\": $(cat parsed-data.json), \"recentTopDecks\": $(cat recent-top-decks.json)}" > ranked-decks.json
        shell: bash

      # Step 5: Commit and push changes
      - name: Commit changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add ranked-decks.json
          git commit -m "Update ranked-decks.json"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
