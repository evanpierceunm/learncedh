name: Update Ranked Decks JSON

on:
  schedule:
    # Run every 24 hours at midnight UTC
    - cron: "0 0 * * *"
  workflow_dispatch: # Allow manual triggering

jobs:
  update-json:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Fetch data from API with pagination (commanders list + stats)
      - name: Fetch commander stats from API
        id: fetch_data
        run: |
          total_data="[]"
          after_cursor="null"
          total_count=0
          limit=1800

          while [ $total_count -lt $limit ]; do
            response=$(curl -s -X POST -H "Content-Type: application/json" \
              -d '{"query": "query ($after: String) { commanders(first: 100, sortBy: POPULARITY, minEntries: 0, timePeriod: THREE_MONTHS, after: $after) { edges { cursor node { name stats(filters: { timePeriod: THREE_MONTHS, minSize: 16 }) { conversionRate metaShare } } } pageInfo { endCursor hasNextPage } } }", "variables": {"after": '"$after_cursor"'}}' \
              https://edhtop16.com/api/graphql)

            # Extract edges
            edges=$(echo "$response" | jq '.data.commanders.edges')
            edge_count=$(echo "$edges" | jq 'length')
            total_count=$((total_count + edge_count))

            # Check if total count exceeds the limit
            if [ $total_count -ge $limit ]; then
              # Trim to the first X entries
              remaining_count=$((limit - (total_count - edge_count)))
              edges=$(echo "$edges" | jq ".[0:$remaining_count]")
              total_count=$limit
            fi

            # Append edges to total_data
            total_data=$(echo "$total_data $edges" | jq -s 'add')

            # Break if the limit is reached
            if [ $total_count -ge $limit ]; then
              break
            fi

            # Update after_cursor
            after_cursor=$(echo "$response" | jq '.data.commanders.pageInfo.endCursor')

            # Break if no more pages are available
            hasNextPage=$(echo "$response" | jq '.data.commanders.pageInfo.hasNextPage')
            if [ "$hasNextPage" != "true" ]; then
              break
            fi
          done

          # Parse and save the data
          echo "$total_data" | jq 'map({name: .node.name, conversionRate: .node.stats.conversionRate, metaShare: .node.stats.metaShare})' > parsed-data.json

      # Step 3: Build recentTopDecks map by querying each commander (top 3 entries)
      - name: Fetch recent top decklists per commander
        run: |
          # Extract commander names (one per line)
          jq -r '.[].name' parsed-data.json > commander-names.txt

          # Initialize JSON object map
          echo '{}' > recent-top-decks.json

          # Query each commander for top 3 entries in last 3 months
          # NOTE: This is ~1800 requests in worst case. If you hit rate limits, reduce limit or sample.
          while IFS= read -r commander; do
            if [ -z "$commander" ]; then
              continue
            fi

            response=$(curl -s -X POST -H "Content-Type: application/json" \
              -d "$(jq -n --arg commander "$commander" '{
                query: "query ($timePeriod: TimePeriod!, $minEventSize: Int!) { commander(name: \"\($commander)\") { entries(first: 3, filters: { timePeriod: $timePeriod }) { edges { node { player { name } decklist standing tournament { name size } } } } } }",
                variables: { timePeriod: "THREE_MONTHS", minEventSize: 16 }
              }')" \
              https://edhtop16.com/api/graphql)

            # Build array of entries (or empty)
            decks=$(echo "$response" | jq '(
              .data.commander.entries.edges // []
            ) | map({
              player: (.node.player.name // ""),
              decklist: (.node.decklist // ""),
              standing: (.node.standing // null),
              tournamentName: (.node.tournament.name // ""),
              tournamentSize: (.node.tournament.size // null)
            })')

            # Write into map by commander name
            tmp=$(mktemp)
            jq --arg commander "$commander" --argjson decks "$decks" '. + {($commander): $decks}' recent-top-decks.json > "$tmp"
            mv "$tmp" recent-top-decks.json

          done < commander-names.txt

      # Step 4: Update the JSON file (stats + recent decks)
      - name: Update JSON file
        run: |
          echo "{\"lastUpdated\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"data\": $(cat parsed-data.json), \"recentTopDecks\": $(cat recent-top-decks.json)}" > ranked-decks.json
        shell: bash

      # Step 5: Commit and push changes
      - name: Commit changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add ranked-decks.json
          git commit -m "Update ranked-decks.json"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
